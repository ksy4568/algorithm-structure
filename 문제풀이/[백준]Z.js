// 재귀함수를 사용하여 문제를 해결하는 것!
// 처음에 문제를 풀때는 함수를 만들고 그 함수에 무조건 주어진 인자들을 넣어서 풀어야한다고 생각했다.
// 유연하지 못한 사고.. 조금 더 시야를 넓게..!!
// 어떻게 풀지라는 2일의 고민끝에 못풀고..ㅠㅠ 머릿속에 재귀함수 뿐 아니라 문제를 다르게 해석하는 방법도 필요하다고 느꼈다.

function test(N, R, C) {
  
  // 2 x 2 단위로의 함수를 재귀로 호출할 것이다. 재귀가 동작하는 동안 상위 변수로 선언한
  // result에 1씩 증가할 예정 -> 좌표에 따른 결과값 반환
  let result = 0;

  // 여기서 주의점은 solve라는 함수 안에 주어진 인자를 그대로 넣는다고 생각하면 안된다.
  // 문제를 못풀었던 요인은 주어진 인자를 바로 적용해서 어떻게든 해보려고 했기 때문..
  // n이나 r, c로 도달하는 방법을 어떻게 파악하지가 관건이었다. 그래서 역으로 돌아가고 -1씩해야하나 생각도 해보았다.
  // 하지만 이렇게 solve라는 함수를 생성해서 이 함수의 좌표 인자로는 0과 0을 할당하여 상위 함수에 있는 r과 c를 비교하면 되는거였다..
  function solve(n, r, c) {
    // solve를 재귀로 호출할 것이다. solve는 최소의 2x2단위로까지 내려가서 상하좌우 좌표를 수동으로 계산할 것이다.
    // r과 R, c와 C를 비교하여 같으면 그동안 재귀를 통해 더해주었던 result를 반환하고 그렇지 않다면 result + 1을 해준다.
    if(n === 2) {
      // 위 왼쪽 좌표
      if(r === R && c === C) {
        console.log(result);
        return;
      }
      result += 1;

      // 위 오른쪽 좌표
      if(r === R && c + 1 === C) {
        console.log(result);
        return;
      }
      result += 1;

      // 아래 왼쪽 좌표
      if(r + 1 === R && c === C) {
        console.log(result);
        return;
      }
      result += 1;

      // 아래 오른쪽 좌표
      if(r + 1 === R && c + 1 === C) {
        console.log(result);
        return;
      }
      result += 1;

      // 가장 최소 단위인 2 x 2의 계산이 끝났으면 return을 통해 다음 2 x 2블럭으로 넘어간다.
      return
    }

    // 여기서 solve를 재귀 호출해준다.
    // n은 2로 나눈 값을 넣어준다.
    // n은 / 2로 다음 재귀 함수 인자로 넘어가고
    // r과 c는 또 4등분으로 나누어 재귀호출해준다.
    // 하지만 r과 c를 재귀함수 인자로 넘길 때는 각각 4등분 블럭의 시작점을 넘겨주어야 한다.
    // r과 c에 각각 n / 2를 더한 이유가 그것이다. 4등분한 블럭을 각각 재귀함수로 호출하고
    // 그 안의 좌표값을 블럭이 시작하는 좌표부터 비교해서 더하거나 반환해야하기 때문
    solve(n / 2, r, c)
    solve(n / 2, r, c + n / 2);
    solve(n / 2, r + n / 2, c);
    solve(n / 2, r + n / 2, c + n / 2);
  }
}